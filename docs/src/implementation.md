# Детали реализации

## Сессии и хэндлы

Для использования API плагина сначала нужно создать сессию (запрос `create`), а внутри сессии создать
хэндл плагина (запрос `attach`). После чего, указывая session id и handle id можно слать запросы
`message`, которые уже попадут в плагин.

Есть некоторая путаница с тем, что в сишном API плагинов Janus мы получаем хэндл в колбэке, но
он там почему-то называется session. На самом деле плагины работают только с хэндлами, а сессия
Janus недоступна из плагина, поэтому в контексте кода плагина про сессию можно вообще не думать,
а слова хэндл и сессия считать синонимами.

## Стейт хэндла

Мозилловская обёртка janus-plugin позволяет ассоциировать с каждым хэндлом некоторый объект стейта
с помощью функции `SessionWrapper::associate`. Он вызывается в колбэке `create_session`.

Важно, чтобы хэндл, завёрнутый в `SessionWrapper` не дропнулся, пока хэндл нужен, иначе glib'овский
счётчик ссылок прибьёт хэндл, сишный указатель станет невалидным и возможный последующий дереференс
вызовет сегфолт. Rust не может отследить это при компиляции, потому что он ничего не знает про то,
что C творит в ядре Janus, поэтому дереференс этого указателя ансейфный. Чтобы такого сегфолта не
происходило, мы овним `SessionWrapper` в switchboard через `Switchboard::connect` и держим хэндл
там до тех пор, пока к нему возможны обращения. Также нужно следить, чтобы они зачищались оттуда.
Для этого есть в частности механизм вакуума паблишеров: подробнее об этом в секции про свичборд.

С `SessionWrapper` есть проблема, что ассоциированный стейт не шарится между тредами, поэтому мы
храним там не стейт, а только `SessionId`, который дерайвит `Copy`, а сам стейт хранится отдельно
тоже в свичборде. В стейте хэндла лежат счётчики, нужные для работы с RTP и рекордер, если это
хэндл паблишера.

## Свичборд

Задача свичборда – хранение стейта для роутинга RTP-пакетов от ведущего к зрителям.

### Поля структуры

* `sessions` – тут хранятся сами хэндлы для того, чтобы их не дропнуло раньше нужного (см. выше)
и для того, чтобы с ними вызывать колбэки к ядру Janus из модуля `janus_callbacks`. Хэндлы лежат
под мьютексом, чтобы свичборд был `Sync`: в этом нет проблемы, т.к. к одному хэндлу не должно
быть много одновременных запросов.
* `states` – тут хранятся стейты хэндлов (см. выше).
* `agents` – тут хранится двусторонний маппинг agent id на session id; нужен для обработки отключения
от брокера (`agent.leave`): если агент отключился от брокера, то плагин отключает его хэндл.
* `publishers` – тут маппинг, кто стримит в какой стрим.
* `publishers_subscribers` – тут маппинг, кто смотрит какого паблишера.
* `reader_configs` – тут настройки зрителя, которые он устанавливает сам для себя: хочет ли он
получать видео/аудио или нет.
* `writer_configs` – тут настройки паблишера: должны ли видео/аудио пакеты от него отправляться
зрителям, а также битрейт видео.

### Подключение паблишера

Паблишер подключается в методе `create_stream`.

Если он подключается впервые, то он просто добавляется в `publishers` и ассоциируется с `agent_id`.

Если он подключается повторно с другим хэндлом, например, после рефреша, либо стримить начинает
другой агент при передаче права трансляции в вебинарах, то старый паблишер заменяется новым.

### Подключение зрителя

Зритель подключается через `join_stream`. Это возможно только, когда кто-то уже стримит.

Тут всё просто: он добавляется в маппинг зрителей `publishers_subscribers` и agent id ассоциируется
с хэндлом.

### Отключение хэндла

Отключение хэндла может происходить по следующим причинам:

* Произошёл хэнгап, т.е. закрылся PeerConnection. Тогда ядро Janus дёрнет колбэк `hangup_media`,
а тот в свою очередь вызовет метод `disconnect` на свичборде, который вызывает колбэк `end_session`
для принудительного завершения.
* Агент отвалился от брокера. Тогда брокер отправит событие `agent.leave` в conference, а `conference`
в свою очередь отправит запрос `agent.leave` в Janus. По маппингу agent id в свчиборде находится
хэндл и вызывается `end_session`.
* Паблишера отключило по вакууму (см. ниже).
* Отключился ведущий стрима на который подписан зритель. При этом хэндлы зрителей тоже отключаются.
* Комната conference уже за закрылась и пришёл запрос `stream.upload` на загрузку записи. Если при
этом паблишер всё есть есть и что-то пишется, то он принудительно отключается, чтобы корректно
завершить файл записи через `janus_recorder_close`.

Отключение происходит асинхронно. Сначала вызывается колбэк `end_session`, а когда ядро Janus
отключит хэндл, то вызовет колбэк `destroy_session`, откуда уже на свичборде вызывается метод
`handle_disconnect`, который прибирает хэндл оттуда.

### Вакуум паблишеров

Если паблишер просто закрыл вкладку или у него пропала связь, то хэнгапа не будет. Также его может
и не быть даже при остановке через кнопку паузы в некоторых браузерах.

При этом хэндл висит с link quality = 0 и ждёт, что RTP-пакеты когда-нибудь придут. Чтобы не текла
память, не висели лишние треды и не занимались неиспользуемые порты, эти хэндлы нужно подчищать.
Для этого есть механизм вакуума паблишеров, который отключает хэндлы паблишеров, от которых не было
RTP пакетов больше 5 секунд.

Каждый раз, когда приходит RTP пакет, в стейт хэндла паблишера записывается текущий таймстэмп.
В отдельном треде крутится вызов `vacuum_publishers`, который проверяет, сколько времени прошло
с последнего RTP-пакета у каждого паблишера. Если это больше 5 секунд, то паблишер отключается.

## Детали RTP/RTCP

Эти вещи сделаны по аналогии со стандартным плагином videoroom.

### Управление ключевыми кадрами (FIR/PLI)

FIR (Full Intra Request) – запрос ключевого кадра. Он отправляется по RTCP паблишеру каждый раз,
когда подключается новый зритель в колбэке `setup_media`. Это нужно, чтобы у вновь подключившегося
зрителя сразу была полная картинка, а не только диффы до следующего ключевого кадра. Также FIR
может быть отправлен по запросу от зрителя, который обрабатывается в `incoming_rtcp_impl`.

PLI (Picture Loss Indication) – уведомление для паблишера, что какой-то кадр потерялся или побился,
что браузер зрителя не может его декодировать. Передаётся по запросу от зрителя.

### Управление битрейтом (REMB)

Нагрузка на Janus по CPU и трафику линейно зависит от битрейта.

В вебинарах устанавливается битрейт ведущего 1 Мбит/с, в минигруппах 600 Кбит/с для запиненного
участника и 200 Кбит/с для остальных. В режиме сетки у всех 200 Кбит/с. Управление этим происходит
через writer config.

REMB (Receiver Estimated Maximum Bitrate) – просьба к паблишеру присылать стрим с определённым
битрейтом. Он отправляется в двух случаях:

1. Начальный разгон битрейта (`INITAL_REMBS`).
2. Последующий регулярный раз в 5 секунд (`REMB_INTERVAL`).

